# Async and Await

You can work with promises by using `async` and `await`.

## Async

Adding the `async` keyword to the beginning of a function means that **this function always returns a promise**.

This async example:
``` 
async function f() {
  return 1;
}

f().then(alert); // 1
```

is just another way of writing it with an explicit promise: 

```
async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1
```

**TL;DR**
- `async` ensures that the function returns a promise
- it also wraps any other values in a resolved promise automatically

## Await

Adding the `await` keyword makes JavaScript wait until the promise resolves and returns a result. 

```
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // wait until the promise resolves (*)

  alert(result); // "done!"
}

f();
```

- the function execution"pauses" at `let result = await promise;` and resumes once the promise is resolved.

**TL;DR**
- `await` suspendes the function execution until the promise resolves 
-  once the promise resolves, it resumes function execution with the promise result

**You can use `await`:**
- on class methods. Just prepend `async`
- on "thenables" (objects with a callable `then` method that are promise compatible)

**You can't use `await`:**
- in a non-async function
- in the top-level code (you'd have to wrap it in an anonymous function to make it work)

### CPU Resources:
- Even though the `await` literally suspends the function execution, it doesn't cost us any CPU resources
- This is because the JavaScript engine can do other jobs in the meantime like execute other scripts, handle events, etc

## Re-writing a promise as an `async/await` function 

This function uses a promise to show a GitHub avatar: 
```
function showAvatar(githubUser) {
  return new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  });
}
```

We can re-write it using `async/await` like this so its organized and easy to read: 
```
async function showAvatar() {
  // read our JSON
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  // read github user
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();
  
  // show the avatar
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);
  
  // wait 3 sec
  await new Promise{(resolve, reject) => setTimeout(resolve, 3000));
  });

  img.remove();
  return githubUser;
}
```

## Error handling
**Happy Path:** If a promise resolves normally, then `await` promise returns the result. 
**Sad Path:** If a promise is rejected, it throws the error, just as if there were a throw statement at that line.

Since promises may take some time before it rejects, its best practice to use `try...catch` in place of the `throw`
```
async function f() {

  try {
    let response = await fetch('http://no-such-url');
    let user = await response.json();
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}
```

Without the `try...catch` the promise generated by the `async`function is rejected.
- you will need to add `.catch` to the function call in the code
- this creates more room for error in a large codebase where other developers might not know that the absence of a `try...catch` requires their function call to have a `.catch` statement

## What are the benefits of using `async` and `await`?

- **Elegant syntax:** many find this syntax is easier to read and write than a promise with a chain of `.then` functions. The `await` automatically handles the waiting for us without the need to chain a `.then()`. 

## When not to use `async` and `await`
- **Top-level code:** At the top level of the code you are outside of an async function, and therefore syntactically unable to use await. In this case itâ€™s best practice to add `.then/catch` to handle the final result or falling-through error.

