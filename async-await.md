# Async and Await

You can work with promises by using `async` and `await`.

## Async

Adding the `async` keyword to the beginning of a function means that **this function always returns a promise**.

This async example includes an _implicit_ promise:
``` 
async function f() {
  return 1;
}

f().then(alert); // 1
```

Using `async` is just another way of writing an _explicit_ promise: 

```
async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1
```

**TL;DR**
- `async` ensures that the function returns a promise
- it also wraps any other values in a resolved promise automatically
- its implicit (you don't have to explicity return a promise because `async` makes sure its a promise

## Await

Adding the `await` keyword makes JavaScript wait until the promise resolves and returns a result. 
- it "blocks" the code execution with the async function (blocking is when the execution of additional JS must wait until a non-JS operation completes. This happens because the vent loop is unable to continue running JS while a blocking operation is occuring).

```
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // wait until the promise resolves (*)

  alert(result); // "done!"
}

f();
```

- the function execution "pauses" at `let result = await promise;` and resumes once the promise is resolved.

**TL;DR**
- `await` suspendes the function execution until the promise resolves 
-  once the promise resolves, it resumes function execution with the promise result
-  `await` is always for a single promise
-  `await` only blocks the code execution within the `async` function. It only makes sure that the next line is executed when the promise resolves. So if asyn activity has already started, the `await` will have no effect.

**You can use `await`:**
- on class methods. Just prepend `async`
- multiple times in a single `async` function
- on "thenables" (objects with a callable `then` method that are promise compatible)

**You can't use `await`:**
- in a non-async function
- in the top-level code (you'd have to wrap it in an anonymous function to make it work)

### CPU Resources:
- Even though the `await` literally suspends the function execution, it doesn't cost us any CPU resources
- This is because the JavaScript engine can do other jobs in the meantime like execute other scripts, handle events, etc

## Re-writing a promise as an `async/await` function 

This function uses a promise to show a GitHub avatar: 
```
function showAvatar(githubUser) {
  return new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  });
}
```

We can re-write it using `async/await` like this so its organized and easy to read: 
```
async function showAvatar() {
  // read our JSON
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  // read github user
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();
  
  // show the avatar
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);
  
  // wait 3 sec
  await new Promise{(resolve, reject) => setTimeout(resolve, 3000));
  });

  img.remove();
  return githubUser;
}
```

## Error handling
**Happy Path:** If a promise resolves normally, then `await` promise returns the result. 
**Sad Path:** If a promise is rejected, it throws the error, just as if there were a throw statement at that line.

Since promises may take some time before it rejects, its best practice to use `try...catch` in place of the `throw`
```
async function f() {

  try {
    let response = await fetch('http://no-such-url');
    let user = await response.json();
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}
```

Without the `try...catch` the promise generated by the `async`function is rejected.
- you will need to add `.catch` to the function call in the code
- this creates more room for error in a large codebase where other developers might not know that the absence of a `try...catch` requires their function call to have a `.catch` statement

## What to use `async` and `await`

- **Elegant syntax:** many find this syntax is easier to read and write than a promise with a chain of `.then` functions. The `await` automatically handles the waiting for us without the need to chain a `.then()`. 
- **Waiting on the output of a function:** When the output of one function is dependent on the output of another function, it is a good time to use `await`
- **Parallel functions:** If two functions can run in parallel, then create two different `async` functions and run them in parallel

## When not to use `async` and `await`

- **Top-level code:** At the top level of the code you are outside of an async function, and therefore syntactically unable to use await. In this case itâ€™s best practice to add `.then/catch` to handle the final result or falling-through error.
- **Loops and iterators:** Its best practice not to use `async/await` on loops and iterators because you can fall into the trap of writing sequentially executing code when it could have been done in parallel.
- **Blocking code:** If you being to see a huge `async` function with many `await` functions inside, its better to create smaller async functions so it is clear what is blocking code execution and so you can run some `async` functions in parallel.


## Resources
- https://javascript.info/async-await
- https://eloquentjavascript.net/11_async.html
- https://hackernoon.com/should-i-use-promises-or-async-await-126ab5c98789 
